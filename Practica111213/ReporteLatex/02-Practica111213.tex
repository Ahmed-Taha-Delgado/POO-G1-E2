\documentclass[letterpaper,12pt]{article}
\usepackage[top=1in, left=1.25in, right=1.25in, bottom=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage{amsmath}
\addbibresource{bib/referencias.bib}
\usepackage{subcaption}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Reporte de la Práctica 11, 12 y 13}
\rhead{Programación Orientada a Objetos}

\begin{document}

\tableofcontents
\clearpage

\section{Introducción}

\subsection{Planteamiento del Problema:} Se busca la implementación, comprensión y explicación de los temas de Archivos, Hilos y Patrones en Dart, mediante el análisis de múltiples códigos para cada tema.

\subsection{Motivación:} En esta práctica aprenderemos sobre la correcta aplicación de los temas anteriormente mencionados en programas de Dart para la resolución de problemas con mayor eficiencia.

\subsection{Objetivos:} Crear programas en Dart que aprovechen de forma sencilla y práctica el uso de archivos, hilos y patrones de diseño, para que la aplicación funcione de manera fluida, organizada y pueda reaccionar bien incluso cuando ocurran tareas simultáneas o situaciones inesperadas.

\section{Marco Teórico}

\subsection{Archivos: } Los archivos, en términos computacionales, son conjuntos de datos con un nombre y extensión que permite almacenar información de manera permanente en memoria secundaria, para que pueda ser consultada, utilizada y modificada posteriormente tanto por el usuario como diferentes programas.

Los programas se comunican con los archivos mediante \textit{flujos de datos}. Estos flujos se clasifican en \textbf{flujos de entrada} y \textbf{flujos de salida}. 
\begin{itemize}
    \item \textbf{Flujos de entrada:} cuando los programas reciben información desde archivos o una fuente externa.
    \item \textbf{Flujos de salida:} cuando los programas envían esa información a un destino externo, como lo puede ser el usuario.
\end{itemize} ~\cite{Archivos} ~\cite{Flujos}

\subsection{Hilos: } Un hilo es la unidad mínima de ejecución dentro de un proceso, dichos hilos contienen una sucesión de instrucciones que se ejecutan de manera independiente pero no es totalmente autónomo del proceso.
En el caso de Dart, los hilos no se comunican entre sí directamente ya que no comparten memoria, éstos se comunican mediante \textbf{SendPort}  y \textbf{ReceivePort}, los cuáles enviarán y recibirán mensajes rescpectivamente.~\cite{Hilos}

\subsection{Patrones: }Los patrones de diseño son soluciones aprobadas y documentadas para problemas comunes en el desarrollo de software. Son guíaa o modelos que muestran cómo estructurar clases, objetos y responsabilidades dentro de un programa para que sea más fácil de mantener, extender y comprender. Su principal propósito es mejorar la calidad del software.
Se considerar tres tipos de patrones de software:
\begin{itemize}    
    \item \textbf{Patrones arquitectónicos:} Describen soluciones al mas alto nivel de software y hardware. Normalmente soportan requerimientos no funcionales.
    \item \textbf{Patrones de diseño:} Describen soluciones en un nivel medio de estructuras de software. Normalmente soportan requerimientos funcionales
    \item \textbf{Patrones de programación:} Describen soluciones en un nivel medio de estructuras de software. Normalmente soportan requerimientos funcionales.
\end{itemize}
~\cite{Patrones}

\textbf{Patrón Modelo-Vista-Controlador: }También llamado MVC, es un patrón de arquitectura de software en el cual se utilizan tres componentes, separando la lógica de la aplicación de la lógica de la vista, algo muy útil ya que permite realizar cambios en parte de la aplicación sin afectar a las demás, encargándose el modelo de cuestiones como manejo de datos, generalmente, aunque no obligatoriamente, consultando bases de datos para actualizaciones, consultas, búsquedas, etc.
\\EL controlador es quien se encarga de procesar las solicitudes del usuario, pedirle los datos correspondientes al modelo y de comunicárselos a vista; vista se encarga de la representación visual de los datos, encargándose de toda la interfaz gráfica, no preocupándose el modelo ni el controlador por lo que sucede en esta parte.~\cite{PatronMVC}


\section{Desarrollo}

\subsection{Explicación del código de archivos:}

El código implementado en dart \textbf{main.dart} consta de un menú de opciones que nos permite entender y trabajar con las operaciones básicas de los archivos. El menú cuenta con 3 opciones que explicaremos a continuación y la opción salir. Cada opción manda a llamar a una función que permite realizar la operación ingresada. \\

\textbf{Opción 1. Crear archivo .txt y escribir texto:} Esta función le pide al usuario que ingrese un nombre para crear un archivo, si la cadena ingresada no esta vacía, crea ese nuevo archivo. Al crear el archivo, se le pide al usuario que ingrese el texto que contendrá el archivo, y para indicar que ya termino de escribir lo que se quiere guardar en el archivo, que escriba 'FIN'. El programa, mediante un ciclo \textit{while}, va almacenando las cadenas ingresadas por el usuario en una lista, y si se detecta una cadena 'FIN', se termina el ciclo. Finalmente con un \textit{try-catch}, se intentará crear un archivo con el nombre ingresado inicialmente por el usuario (creando un objeto de tipo \textbf{FILE} e indicando su nombre en el constructor), y con el método \textbf{writeAsStringSync} se escriben las cadenas guardadas en la lista de cadenas, dentro del archivo creado. En caso de no poder crear o escribir en el archivo, el bloque \textit{catch} muestra que ocurrio un error al guardar el archivo. \\

\textbf{Opción 2. Leer archivo existente:} Esta función le pide al usuario que ingrese el nombre o ruta del archivo que desea leer, si el nombre o ruta ingresado no se encuentra se termina esta funcion. Si la ejecución continua, con un \textit{try-catch} se intentará abrir un archivo con el nombre o ruta (indicándolo en el constructor), y leerlo con el método \textbf{readAsStringSync}, para posteriormente imprimirlo. \\

\textbf{Opción 3. Sobrescribir archivo existente:} Esta función le pide al usuario que ingrese el nombre o ruta del archivo a sobrescribir, si el nombre o ruta no se encuentra, se termina la funcion. Si el archivo se encuentra, se abre el archivo y se le pide confirmacion al usuario para sobrescribir el archivo, indicandole que esta accion borrara todo su contenido. En caso de aceptar la sobrescritura, de la misma manera que la primera opcion, se le pide al usuario que ingrese el texto y para terminar escriba 'FIN', y con un ciclo while se almacenan las cadenas en una lista, para que finalmente con un \textit{try-catch}, se intente sobrescribir el archivo con el método \textbf{writeAsStringSync}, agregando las cadenas guardadas en la lista al archivo.


\subsection{Explicación de los códigos de Hilos: }
En el \textbf{Ejemplo1.dart} se comienza creando el método asíncrono main, dentro del mismo se manda a imprimir 'Inicio', después se crea una tarea asíncrona la cuál tendrá un retraso de 2 segundos pero no se interrumpirá el flujo del programa sino que este sigue hasta su final imprimiendo 'Fin inmediato (sin esperar)', lo cuál nos indica que el programa no ha esperado a que la tarea retrasada termine para que el programa concluya, dos segundos después de la ejecución finalizará la tarea con retraso y se imprime 'Tarea asíncrona completada'. \\

En \textbf{Ejemplo2.dart} tenemos la misma base que en el ejemplo anterior, pero en esta ocasión a la tarea asíncrona se le añade la palabra \textbf{await} al inicio de la línea. Con esto es conseguido que al ejecutar el programa, se inicie \textbf{main} pero no seguirá hasta el final, sino que el flujo se ve interrumpido hasta que la tarea asíncrona termine (2 segundos) para posteriormente terminar la ejecución. \\

En \textbf{Ejemplo3.dart} Comienza importando la librería \textbf{dart:isolate} que permite crear y manejar isolates. Luego se define el método tarea que enviará el mensaje con \textbf{SendPort}, posteriormente en main, se crea un \textbf{ReceivePort} que recibirá el mensaje del isolate tarea ya definido. Después se crea un isolate principal con \textbf{isolate.spawn}, al cuál se le pasará el \textbf{SendPort} asociado al \textbf{ReceivePort} para finalmente hacer que nuestro isolate principal escuche los mensajes con \textbf{ReceivePort.listen} y después los mande a imprimir. \\

En \textbf{Ejemplo4.dart} nuevamente se utiliza la librería \textbf{dart:isolate}, después se define la función \textbf{sumaGrande}, en esta se hace la suma de los números desde 0 hasta 500 millones y se envía el resultado al isolate principal en main. Por su lado, en main se crean el ReceivePort y el isolate principal al cuál se le pasa el total de la suma con \textbf{ReceivePort.listen} y se manda a imprimir, finalmente añaden algunas impresiones para indicar al usuario que está pasando al ejecutar. \\

En \textbf{Ejemplo5.dart} se implementa una comunicación bidireccional más compleja entre hilos. Primero se define la función \textbf{worker}, la cual crea su propio \textbf{ReceivePort} interno y envía su dirección (\textbf{SendPort}) al hilo principal, permitiendo así que el main sepa a dónde enviarle mensajes. En \textbf{main}, al escuchar a través de su \textbf{ReceivePort}, se distingue si el mensaje recibido es un puerto (para establecer la conexión) o una cadena de texto (una respuesta). Una vez que \textbf{main} obtiene el puerto worker, le envía un mensaje; el worker lo procesa, devuelve una respuesta y finalmente el programa principal cierra los puertos y termina el isolate con \textbf{isolate.kill}. \\

En \textbf{Ejemplo6.dart} se realiza la misma operación matemática que en el ejemplo 4, pero esta vez de forma síncrona y sin utilizar la librería \textbf{dart:isolate}. El programa inicia imprimiendo 'Inicio' y procede a ejecutar el ciclo \textbf{for} de 500 millones de iteraciones directamente en el hilo principal. Esto provoca que el flujo de ejecución se bloquee totalmente esperando a que termine el cálculo; solo cuando la suma ha finalizado se imprime el 'Resultado' y posteriormente 'Fin', demostrando cómo una tarea pesada puede congelar la ejecución si no se delega a un hilo paralelo. \\

\subsection{Explicación del código de patrones: }
Considerando \textbf{main.dart} como el código principal proporcionado, este código implementa un patrón Modelo-Vista-Controlador(MVC), las clases que funcionan como Modelo son los pokemón y sus ataques, teniendo primero una clase \textit{pokemon} en la cual solo se establecen atributos como el nombre, algunas estadísticas y el tipo, teniendo unicamente un constructor el cual establece la vida, nivel y tipo a los dados, mientras que para la vida y velocidad utiliza un número aleatorio; luego se crean dos clases que heredan, para los pokemón tipo fuego y hierba que utilizan el constructor de la clase padre cambiando unicamente el tipo.
\\Luego se tiene la clase \textit{ataque}, la cual cuenta con el nombre del ataque, la potencia y el tipo, contando con un constructor que solo relaciona los valores dados con su respectivo atributo, y al igual que con la clase \textit{pokemon}, se tienen tres clases que heredan para movimientos tipo fuego, normal y hierba, las cuales usan el constructor del padre cambiando unicamente el tipo de ataque. \\

Para la parte de Vista, se tiene primero una clase abstracta que se utilizara de interfaz, en donde se establece que se tendrán los métodos \textit{mostrarInformcacionPokemon, mostrarAtaque, mostrarSuperEfectivo, mostrarPocoEfectivo, mostrarDanio, mostrarDesmayo, mostrarSiguienteTurno, mostrarGanador}, ya dentro de la clase \textit{ConsoleCombateView} se implementa la interfaz, y se escribe lo que mostrara cada método en consola, accediendo a los datos de los pokemón creados y en combate, de ser necesario. \\

Para la parte del controlador, se tiene una clase \textit{CombatController}, la cual se encarga de manejar la lógica de los ataques, de los turnos, y de lo que se mostrara en pantalla, usando sobretodo un objeto de la clase padre de vista \textit{CombateView}, siendo realmente impresiones sencillas de puro texto las que realiza por si sola la clase, y estableciendo el objeto según el tipo de objeto hijo de \textit{CombateView} que se pase al crear el objeto \textit{CombateController}, aunque manejando eventos como los ataques a usar sin intervención del usuario, por el momento. \\

Por ultimo en un método \textit{main}, ya fuera de cualquier clase, se representa lo que podría ser una interacción con el usuario, creando un objeto \textit{ConsoleCombateView} para dárselo a un objeto de clase \textit{CombateController}, se crean dos pokemón diferentes, un ataque y se inicializa un combate con  el método \textit{iniciarCombate} del controlador creado, dándole como datos los pokemón creados y el ataque. \\

También se nos proporciona el código \textbf{singleton.dart}. Este programa nos muestra una plantilla para crear el sistema de impresión de una impresora. Cuenta con la clase \textbf{Documento} que contendra los atributos de un archivo a imprimir: \textit{id, usuario, nombre, contenido}. Esta clase sobrescribe el método \textbf{toString} para darle un formato bonito a la impresión de los atributos. \\

Luego cuenta con la clase \textbf{Impresora} implementando el diseño de singleton, que se caracteriza por tener una instancia estática, un constructor privado, y un factory que devuelve siempre la misma instancia. \\

La clase \textbf{Impresora}, ademas de las características anteriores, cuenta con una cola para representar la cola de impresión, y una lista para el historial de documentos impresos. Así como los métodos \textbf{enviarDocumento}, para agregar un documento a la cola de impresión; \textbf{imprimirSiguiente}, para imprimir el siguiente elemento de la cola de impresión con un formato especifico; \textbf{mostrarCola}, para imprimir los elementos de la cola con un formato especifico; y \textbf{mostrarHistorial}, para mostrar el historial de documentos impresos con un formato especifico. \\

En el main, se crean 2 impresoras con ayuda del patrón de diseño, y se agregan algunos documentos a ambas impresoras, para posteriormente utilizar los métodos anteriores para mostrar la cola de impresión, el historial de documentos impresos, e imprimir los documentos.
 
\clearpage

\section{Diagramas UML}

\subsection{Diagramas del código de archivos:}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/Clase UML Archivos.png}
    \caption*{Diagrama UML de Clases}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/Diagrama de secuencia archivos.png}
    \caption*{Diagrama UML de Secuencia}
\end{figure}

\subsection{Diagramas de los códigos de Hilos: }

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/EstaticoEjemplo3.png}
    \caption*{Diagrama UML estático del Ejemplo 3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/DinamicoEjemplo4.png}
    \caption*{Diagrama UML dinámico del Ejemplo 3}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/EstaticoEjemplo4.png}
    \caption*{Diagrama UML estático del Ejemplo 4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/DinamicoEjemplo4.png}
    \caption*{Diagrama UML dinámico del Ejemplo 4}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/EstaticoEjemplo6.png}
    \caption*{Diagrama UML estático del Ejemplo 6}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/DinamicoEjemplo6.png}
    \caption*{Diagrama UML dinámico del Ejemplo 6}
\end{figure}

\subsection{Diagramas de código de patrón MVC}

\clearpage

\section{Resultados}

\subsection{Resultados del código de archivos}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.49\linewidth]{Imagenes/Crear archivo.png}
    \includegraphics[width=0.46\linewidth]{Imagenes/Sobrescribir archivo.png}
    \includegraphics[width=0.49\linewidth]{Imagenes/Leer archivo.png}
    \caption*{Ejecución del código de archivos}
\end{figure}

\subsection{Resultados del código de hilos}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{Imagenes/ejemplo1.png}
    \caption{Ëjemplo 1}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{Imagenes/ejemplo2.png}
    \caption*{Ejemplo 2}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{Imagenes/ejemplo3.png}
    \caption*{Ejemplo 3}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Imagenes/ejemplo4.png}
    \caption*{Ejemplo 4}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Imagenes/ejemplo5.png}
    \caption*{Ejemplo 5}
\end{figure}   
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{Imagenes/ejemplo6.png}
    \caption*{Ejemplo 6}
\end{figure}

\subsection{Resultados del código de patrón}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Practica111213/ReporteLatex/Imagenes/patronMVC.png}
    \caption*{Ejecución del patrón MVC}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{Practica111213/ReporteLatex/Imagenes/singleton.png}
    \caption*{Ejecución del patrón de Singleton}
    \label{fig:placeholder}
\end{figure}
    
\clearpage

\section{Conclusiones}
En esta práctica logramos comprender cómo trabajar de manera correcta con archivos, para almacenar información que puede ser modificada y consultada posteriormente; así como hilos de ejecución, que permiten la realización de diferentes tareas al mismo tiempo (de manera paralela); y patrones de diseño en Dart, que nos permiten ajustar una plantilla para ser utilizada para un mismo tipo de problema, cambiando sus caracteristicas pero manteniendo una misma estructura. Identificamos la forma en como cada uno de estos elementos son esenciales para así construir aplicaciones más eficientes, organizadas y preparadas para situaciones complejas.

\printbibliography

\end{document}