\documentclass[letterpaper,12pt]{article}
\usepackage[top=1in, left=1.25in, right=1.25in, bottom=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{float}
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex}
\usepackage{amsmath}
\addbibresource{bib/referencias.bib}
\usepackage{subcaption}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Reporte de la Práctica 9 y 10}
\rhead{Programación Orientada a Objetos}

\begin{document}

\tableofcontents
\clearpage

\section{Introducción}

\begin{itemize}
\item \textbf{Planteamiento del Problema:} Se busca la implementación de una aplicación de Dart, que simule los servicios de un taller mecánico mediante diferentes clases en las que se manejarán métodos sobrescritos, excepciones y errores para asegurar un correcto funcionamiento del programa.

\item \textbf{Motivación:} En esta práctica aprenderemos sobre la gestión de excepciones y errores en Dart para evitar comportamientos inesperados, crasheos del programa o simplemente enviar mensajes claros al usuario cuando ha ocurrido un problema.

\item \textbf{Objetivos:} Crear un programa que garantice que nuestro programa es estable y sea capaz de responder ante situaciones inesperadas, todo esto con la finalidad de brindar al usuario una mejor experiencia a la hora de ejecutar.

\end{itemize}

\section{Marco Teórico}
\begin{itemize}

    \item \textbf{Flutter y Dart:} Flutter es un kit de herramientas de interfaz de usuario de código abierto desarrollado por \textit{Google} utilizado para crear aplicaciones. Tiene soporte para seis plataformas: iOS, Android, web, Windows, MacOS y Linux.

    Dart es un lenguaje de programación orientado a objetos desarrollado por \textit{Google}, que también permite la programación estructurada. Este lenguaje fue diseñado para crear aplicaciones rápidas y fáciles de mantener. Sigue una sintaxis similar a C y Java.

    Flutter trabaja con el lenguaje Dart, y de esta forma se complementan para crear aplicaciones completas, robustas y eficientes. ~\cite{FlutterDart1} ~\cite{FlutterDart2}
    
    \item \textbf{Excepciones y errores:} Una excepción es cuando ocurre un evento que altera el flujo normal del programa en ejecución. Las excepciones ocasionan la finalización abrupta de la ejecución del programa, y muestran la razón por la cual se generó la excepción.

    Un error es un problema, del cual no se puede hacer nada para resolverlo, y suele tratarse de problemas mas profundos que el programador no puede abordar; por ejemplo, un error en la maquina virtual de Java.
    
    Existen mecanismos que permiten controlar y manejar cuando se 'lanza' una excepción; de esta manera se puede continuar con la ejecución del programa tomando en cuenta las posibles excepciones que podrían ser lanzadas.

    El manejo de excepciones se realiza con el bloque \textit{try-catch-finally}. Dentro del bloque \textit{try} se coloca el código que podría generar una excepción. En el bloque \textit{catch} se especifica el tipo de excepción que será capturada y lo que realizará el programa en ese caso. En el bloque \textit{finally} se coloca el código que siempre se ejecutará, independientemente de que ocurra el \textit{try} o el \textit{catch}. Estos bloques pueden tener mas de un \textit{catch}, y puede haber bloques sin el bloque \textit{try} (\textit{catch-finally}) o sin el bloque \textit{catch} (\textit{try-finally}). 

    Se puede lanzar una excepción explícitamente, con la palabra reservada \textit{throw}, esto detiene el flujo del programa indicando un problema.

    En Java, se puede declarar que un método podría lanzar excepciones con la palabra reservada \textit{throws}. De esta forma no se manejan las excepciones dentro del método y son trabajo de los métodos que llamen a ese método. Si los métodos que llaman a esas funciones tampoco manejan las excepciones, se llama 'propagación de excepciones', donde la excepción es recorrida hasta el método que la maneje; y si no es manejada, se lanza la excepción y se termina la ejecución del programa como pasaría normalmente.      ~\cite{Excepciones}

    \item \textbf{UML:} UML, siglas de Lenguaje Unificado de Modelado, son un tipo de diagramas utilizados para modelar visualmente la sintaxis y semántica de un desarrollo de software complejo. Consiste en diferentes diagramas que describen los límites, estructura y comportamiento del sistema y los objetos que contiene. Los diagramas UML guardan una relación directa con la programación orientada a objetos. ~\cite{UML}
    

\end{itemize}

\section{Desarrollo}
El código proporcionado trae en un solo archivo distintas clases y funciones independientes, las cuales podrán ser usadas por cualquier otra clase y método del mismo código.

Lo primero es una clase abstracta \textbf{ServicioTaller}, que se utilizará como interfaz con dos métodos a implementar. Posteriormente, se tiene otra clase abstracta, \textbf{Vehiculo}, que implementa la primera clase haciendo uso de la palabra reservada \textit{implements}. Dentro de esta clase abstracta se tienen tres atributos privados: \textit{marca} (String), \textit{modelo} (String) y \textit{anio} (int). Se asignan como métodos privados con la barra baja antes del nombre, al igual que. La clase consta del constructor, los getters, los setters y un método \textbf{descripcion} que retorna lo que se obtiene de los getters, interpolando el valor que devuelven a Strings gracias al uso de '\$'.

Los setters de la clase abstracta son donde se implementan las excepciones, ya que dentro de cada uno de estos setters se hace una evaluación, como que la marca y el modelo no estén vacíos o que el año sea mayor a 1900, en caso de no cumplir alguna de estas condiciones, se utilizará la palabra reservada \textit{throw} para 'lanzar' una excepción del tipo \textit{ArgumentError}, con un mensaje personalizado dependiendo del setter en el que se haya detectado un error. En caso de que no se cumpla con la condición para lanzar el \textit{ArgumentError}, se asignará la variable de forma normal.

Luego se encuentra la clase \textbf{Auto} la cual hereda de \textbf{Vehiculo}, esta añade otro atributo privado de tipo \textit{booleano}, el cual es el aire acondicionado. Su constructor ademas de inicializar su atributo único, se apoya del constructor de la clase padre, haciendo uso de \textit{super}, teniendo ademas su propio set y get para su atributo único. La clase consta ademas con la sobrescritura de los dos métodos declarados en la interfaz y del método \textbf{descripcion} de la clase padre: \textbf{calcularServicio} cuenta con dos variables con valores fijos y un tercero el cual cambiará su valor dependiendo de lo que contenga el atributo que representa el aire acondicionado, evaluandolo con una condición ternaria y devolviendo la suma de los tres atributos. \textbf{generarReporteServicio} solo devuelve de forma ordenada los atributos del objeto y el valor que regresa \textbf{calcularServicio}, limitándose a solo mostrar 2 dígitos luego del punto decimal. \textbf{descripcion} hace uso del método del mismo nombre de la clase padre y le añade ademas una parte de texto para mostrar si el auto cuenta con aire acondicionado o no, para devolver todo en una sola cadena de caracteres.

Luego se tiene a la clase \textbf{Moto} la cual también hereda de \textbf{Vehiculo}, realiza lo mismo que \textbf{Auto} pero intercambiando el aire acondicionado por el cilindrado de tipo \textit{int}, lo que lleva a ciertos cambios, en el set se agrega la evaluación del cilindrado, para en caso de que se intente ingresar un cilindrado negativo, lanzar una excepción del tipo \textit{ArgumentError} con el mensaje de que el cilindrado debe ser positivo, la sobrescritura de \textbf{calcularServicio} es bastante parecida a la de \textbf{Auto} ya que cuenta con valores fijos y evalúa en una condición ternaria el atributo único de la clase, y en \textbf{generarReporteServicio} y \textbf{descripcion} se añade la impresión del atributo único.

La ultima clase que se tiene es \textbf{Camion} la cual hereda de \textbf{Vehiculo} y es muy parecida a \textbf{Moto} cambiando el cilindrado por la capacidad de toneladas de tipo \textit{double}, su propio constructor que también se apoya del de la clase padre y su propio set y get; teniendo en el set una evaluación la cual arrojará un \textit{ArgumentError} con mensaje personalizado en caso de que la capacidad ingresada sea igual o menor que 0, la sobrescritura de \textbf{calcularServicio} cuenta con 3 variables con un valor fijo y una cuarta variable cuyo valor dependerá de la capacidad de toneladas. La sobrescritura de \textbf{generarReporteSericio} y \textbf{descripcion} es muy parecida a la de \textbf{Moto}.

Se tienen las funciones que podrá usar el código, primero se tiene \textbf{leerLinea} la cual recibe un \textit{String} el cual muestra en consola, para en la misma linea leer lo que ingrese el usuario y almacenarlo en una variable linea de tipo \textit{final} para terminar devolviendo lo que se guardó en linea o no devolviendo nada si es que el usuario no ingreso ningún dato.

\textbf{leerEntero} también espera recibir un \textit{String} para dentro de un ciclo while el cual no se puede romper, imprimirlo en consola, leer lo que escriba el usuario y guardarlo en una variable \textit{linea}, la cual en caso de ser nula se pasara a la siguiente iteración del ciclo; en caso contrario se creará la variable \textit{valor} y se igualará a lo que almacena \textit{linea} pero casteado a \textit{int}. En caso de que la variable \textit{valor} no sea nula, se devolverá lo que contiene, rompiendo el ciclo, y en cualquier otro caso se imprimirá que el valor ingresado es inválido; lo que realiza este método se replica en \textbf{leerDouble} pero cambiando el casteo de linea a tipo \textit{int} por un casteo a tipo \textit{double}.

\textbf{leerBoolSN} realiza algo parecido a los últimos dos métodos, pero en vez de crear una variable \textit{valor}, crea una variable \textit{l} y la iguala a lo que contenga linea pero sin espacios y en minúsculas, para posteriormente evaluar si contiene una 's' o una 'n' para devolver true o false respectivamente, o en todo caso imprimir que se ingrese una 's' o una 'n'.

Luego están las funciones \textbf{crearAutoInteractivo}, \textbf{crearMotoInteractiva} y \textbf{crearCamionInteractivo}, las cuales crean un objeto de tipo \textbf{Auto}, \textbf{Moto} y \textbf{Camion} respectivamente, haciendo uso de las funciones leer, para almacenar los valores que necesita cada objeto y terminar devolviendo el objeto creado con los valores dados.

Luego se tienen las funciones \textbf{mostrarListadoBasico} y \textbf{mostrarReportesDetallados}, ambas esperan recibir una lista de objetos de tipo \textbf{Vehiculo} y evalúan si esta vacía para imprimir que aun no se tienen registros y no hacer nada más; pero en caso de tener registros, ambas funciones recorrerán la lista dada, y en el caso de la primera función, imprimirá lo que devuelva el método \textbf{descripcion} y \textbf{calcularServicio} de cada objeto de la lista; mientras que en el caso de la segunda, imprimirá lo que devuelva el método \textbf{generarReporteServicio}.

Y por último, la función \textbf{main} crea una lista de objetos de tipo \textbf{Vehiculo} llamada flotilla, y mediante un ciclo while se imprimirá un menú de opciones, el cual hace uso de \textbf{leerEntero} para almacenar la opción del usuario. En las opciones 4, 5 y 0, solo se llama a su función respectiva o se termina el ciclo; sin embargo, las opciones 1, 2 y 3 se encargan de registrar un nuevo tipo de vehículo y tienen una evaluación de excepciones.

Las tres opciones, dentro de un \textit{try}, crean un tipo de objeto \textbf{Vehiculo} igualado a lo que devuelva la función crear interactivo correspondiente, para luego añadirlo a la lista e indicar que el vehículo se agregó. Luego, dentro de un \textit{catch}, atrapará lo que se haya lanzado en el primer \textit{throw} ejecutado y se nombrará la excepción como \textit{e}, para luego imprimir que ocurrió un error junto al mensaje personalizado que tenga \textit{e}; por lo que de esta manera si se ingresó algún dato incorrecto al momento de registrar el vehículo, se imprimirá hasta que se hayan ingresado todos los datos, indicando donde ocurrió el error al momento de registrar, pero mostrando unicamente el primer error encontrado.
  

\section{Diagramas UML}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/Clase UML.png}
    \caption*{Diagrama UML de Clases}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{Imagenes/Diagrama de secuencia.png}
    \caption*{Diagrama UML de Secuencia}
\end{figure}

\section{Resultados}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/auto.png}
    \caption*{registro de un automóvil}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/moto.png}
    \caption*{registro de una motocicleta}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/camion.png}
    \caption*{Registro de un camión}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/resumen.png}
    \caption*{Vista de todos los vehículos registrados}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{Imagenes/reportes.png}
    \caption*{Reportes detallados para cada vehículo}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.49\linewidth]{Imagenes/excepcion1.png}
    \includegraphics[width=0.49\linewidth]{Imagenes/excepcion2.png}
    \includegraphics[width=0.49\linewidth]{Imagenes/excepcion3.png}
    \includegraphics[width=0.49\linewidth]{Imagenes/excepcion4.png}
    \caption*{Muestras de algunos errores posibles}
\end{figure}

\section{Conclusiones}
En ésta práctica logramos adquirir una correcta comprensión y gestión de excepciones y errores en Dart, entendiendo cómo éstas herramientas contribuyen a mantener un flujo de ejecución estable y controlado incluso ante situaciones inesperadas. A través del uso de bloques \textbf{try} - \textbf{catch} y la creación de excepciones personalizadas, se observó cómo es posible anticipar fallos y manejar condiciones especiales. Además, se puede destacar que un buen manejo de errores mejora la legibilidad y la estabilidad del código o aplicación, haciéndolas más profesionales. Por lo que en esta práctica se subrayó la relevancia de diseñar clases y métodos que consideren explícitamente los posibles escenarios de error para lograr sistemas más organizados, seguros y eficientes.
\printbibliography

\end{document}